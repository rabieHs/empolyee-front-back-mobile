const express = require('express');
const router = express.Router();
const mysql = require('mysql2');
const auth = require('../middleware/auth');

// Configuration de la connexion MySQL
const pool = mysql.createPool({
    host: process.env.DB_HOST,
    user: process.env.DB_USER,
    password: process.env.DB_PASSWORD,
    database: process.env.DB_NAME,
    waitForConnections: true,
    connectionLimit: 10,
    queueLimit: 0
});

const promisePool = pool.promise();

// Route principale pour r√©cup√©rer les demandes selon le r√¥le de l'utilisateur
router.get('/', async (req, res) => {
    try {
        const currentUser = req.user;
        console.log('üîç GET /api/requests - User:', currentUser.id, 'Role:', currentUser.role);
        let requests = [];

        switch (currentUser.role) {
            case 'admin':
                // L'admin voit toutes les demandes
                console.log('üë®‚Äçüíº Admin: Loading all requests');
                const [adminRequests] = await promisePool.execute(`
                    SELECT r.*,
                           u.firstname,
                           u.lastname,
                           u.email,
                           d.name as department_name,
                           pi.cin,
                           pi.phone,
                           pri.position
                    FROM requests r
                    JOIN users u ON r.user_id = u.id
                    LEFT JOIN departments d ON u.department_id = d.id
                    LEFT JOIN personal_info pi ON u.id = pi.user_id
                    LEFT JOIN professional_info pri ON u.id = pri.user_id
                    ORDER BY r.created_at DESC
                `);
                requests = adminRequests;
                console.log('üìä Admin found', requests.length, 'requests');
                break;

            case 'chef':
                // Le chef voit toutes les demandes (filtrage c√¥t√© client pour cong√© et formation)
                console.log('üë®‚Äçüç≥ Chef: Loading all requests for filtering');
                const [chefRequests] = await promisePool.execute(`
                    SELECT r.*,
                           u.firstname,
                           u.lastname,
                           u.email,
                           d.name as department_name,
                           pi.cin,
                           pi.phone,
                           pri.position
                    FROM requests r
                    JOIN users u ON r.user_id = u.id
                    LEFT JOIN departments d ON u.department_id = d.id
                    LEFT JOIN personal_info pi ON u.id = pi.user_id
                    LEFT JOIN professional_info pri ON u.id = pri.user_id
                    ORDER BY r.created_at DESC
                `);
                requests = chefRequests;
                console.log('üìä Chef found', requests.length, 'total requests');
                break;

            case 'user':
            default:
                // L'utilisateur voit seulement ses propres demandes
                console.log('üë§ User: Loading personal requests for user', currentUser.id);
                const [userRequests] = await promisePool.execute(
                    'SELECT * FROM requests WHERE user_id = ? ORDER BY created_at DESC',
                    [currentUser.id]
                );
                requests = userRequests;
                console.log('üìä User found', requests.length, 'personal requests');
                break;
        }

        // Ajouter les informations utilisateur pour chaque demande si pas d√©j√† pr√©sentes
        const requestsWithUserInfo = requests.map(request => {
            return {
                ...request,
                user: {
                    id: request.user_id,
                    firstname: request.firstname || 'Inconnu',
                    lastname: request.lastname || '',
                    email: request.email || ''
                }
            };
        });

        console.log('‚úÖ Sending', requestsWithUserInfo.length, 'requests to client');
        res.json(requestsWithUserInfo);
    } catch (error) {
        console.error('Erreur lors de la r√©cup√©ration des demandes:', error);
        res.status(500).json({ message: 'Erreur lors de la r√©cup√©ration des demandes' });
    }
});

/**
 * @swagger
 * /api/requests/all:
 *   get:
 *     summary: Get all requests (admin only)
 *     tags: [Requests]
 *     security:
 *       - bearerAuth: []
 *     responses:
 *       200:
 *         description: List of all requests
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 $ref: '#/components/schemas/Request'
 *       403:
 *         description: Access denied
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/Error'
 *       500:
 *         description: Internal server error
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/Error'
 */
// R√©cup√©rer toutes les demandes (admin seulement)
router.get('/all', async (req, res) => {
    try {
        // V√©rifier si l'utilisateur est admin
        if (req.user.role !== 'admin') {
            return res.status(403).json({ message: 'Acc√®s non autoris√©' });
        }

        // R√©cup√©rer toutes les demandes avec les informations des utilisateurs
        const [requests] = await promisePool.execute(`
            SELECT r.*,
                   u.firstname,
                   u.lastname,
                   u.email,
                   d.name as department_name,
                   pi.cin,
                   pi.phone,
                   pri.position
            FROM requests r
            JOIN users u ON r.user_id = u.id
            LEFT JOIN departments d ON u.department_id = d.id
            LEFT JOIN personal_info pi ON u.id = pi.user_id
            LEFT JOIN professional_info pri ON u.id = pri.user_id
            ORDER BY r.created_at DESC
        `);

        res.json(requests);
    } catch (error) {
        console.error('Erreur lors de la r√©cup√©ration des demandes:', error);
        res.status(500).json({ message: 'Erreur lors de la r√©cup√©ration des demandes' });
    }
});

// R√©cup√©rer les demandes des subordonn√©s du chef
router.get('/subordinates', async (req, res) => {
    try {
        if (req.user.role !== 'chef') {
            return res.status(403).json({ message: 'Acc√®s r√©serv√© au chef' });
        }
        // R√©cup√©rer les demandes des utilisateurs dont le chef_id = req.user.id
        const [requests] = await promisePool.execute(`
            SELECT r.*, u.firstname, u.lastname, u.email
            FROM requests r
            JOIN users u ON r.user_id = u.id
            WHERE u.chef_id = ?
            ORDER BY r.created_at DESC
        `, [req.user.id]);
        res.json(requests);
    } catch (error) {
        console.error('Erreur lors de la r√©cup√©ration des demandes des subordonn√©s:', error);
        res.status(500).json({ message: 'Erreur lors de la r√©cup√©ration des demandes des subordonn√©s' });
    }
});

// R√©cup√©rer les demandes d'un utilisateur
router.get('/user/:userId', async (req, res) => {
    try {
        const userId = req.params.userId;

        // V√©rifier si l'utilisateur acc√®de √† ses propres demandes ou est admin
        if (req.user.id !== parseInt(userId) && req.user.role !== 'admin') {
            return res.status(403).json({ message: 'Acc√®s non autoris√©' });
        }

        const [requests] = await promisePool.execute(
            'SELECT * FROM requests WHERE user_id = ? ORDER BY created_at DESC',
            [userId]
        );

        res.json(requests);
    } catch (error) {
        console.error('Erreur lors de la r√©cup√©ration des demandes:', error);
        res.status(500).json({ message: 'Erreur lors de la r√©cup√©ration des demandes' });
    }
});

// Endpoint pour la compatibilit√© avec l'ancienne version mobile
// R√©cup√©rer les demandes de l'utilisateur connect√© (sans param√®tre userId)
router.get('/user', async (req, res) => {
    try {
        console.log('üì± [MOBILE COMPAT] R√©cup√©ration des demandes pour l\'utilisateur connect√©:', req.user.id);

        // Utiliser l'ID de l'utilisateur connect√© depuis le token JWT
        const userId = req.user.id;

        const [requests] = await promisePool.execute(
            'SELECT * FROM requests WHERE user_id = ? ORDER BY created_at DESC',
            [userId]
        );

        console.log('üì± [MOBILE COMPAT] Demandes trouv√©es:', requests.length);

        // Ajouter les informations utilisateur pour chaque demande
        const requestsWithUserInfo = requests.map(request => {
            return {
                ...request,
                user: {
                    id: request.user_id,
                    firstname: request.firstname || 'Inconnu',
                    lastname: request.lastname || '',
                    email: request.email || ''
                }
            };
        });

        res.json(requestsWithUserInfo);
    } catch (error) {
        console.error('Erreur lors de la r√©cup√©ration des demandes utilisateur:', error);
        res.status(500).json({ message: 'Erreur lors de la r√©cup√©ration des demandes' });
    }
});

/**
 * @swagger
 * /api/requests:
 *   post:
 *     summary: Create a new request
 *     tags: [Requests]
 *     security:
 *       - bearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             $ref: '#/components/schemas/CreateRequestBody'
 *     responses:
 *       201:
 *         description: Request created successfully
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 id:
 *                   type: string
 *                 message:
 *                   type: string
 *                 request:
 *                   $ref: '#/components/schemas/Request'
 *       400:
 *         description: Bad request
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/Error'
 *       500:
 *         description: Internal server error
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/Error'
 */
// Cr√©er une nouvelle demande
router.post('/', async (req, res) => {
    try {
        const { type, details, start_date, end_date, description, working_days } = req.body;

        // Importer le mod√®le Request pour utiliser sa m√©thode createRequest
        const Request = require('../models/request');

        // Cr√©er la demande en utilisant le mod√®le Request
        // Cette m√©thode s'occupe d'ajouter la demande dans la base de donn√©es et de cr√©er les notifications
        const newRequest = await Request.createRequest(
            req.user.id,
            type,
            start_date || new Date().toISOString().split('T')[0], // Date de d√©but (aujourd'hui par d√©faut)
            end_date || new Date().toISOString().split('T')[0],   // Date de fin (aujourd'hui par d√©faut)
            description || `Demande de ${type}`,                  // Description par d√©faut
            details,                                             // D√©tails sp√©cifiques au type de demande
            working_days || 1                                    // Nombre de jours ouvrables
        );

        // Informer le client que la demande a √©t√© cr√©√©e avec succ√®s
        res.status(201).json({
            id: newRequest.id,
            message: 'Demande cr√©√©e avec succ√®s et enregistr√©e dans la base de donn√©es',
            request: newRequest
        });
    } catch (error) {
        console.error('Erreur lors de la cr√©ation de la demande:', error);
        res.status(500).json({ message: 'Erreur lors de la cr√©ation de la demande', error: error.message });
    }
});

/**
 * @swagger
 * /api/requests/{id}/status:
 *   patch:
 *     summary: Update request status (admin or chef only)
 *     tags: [Requests]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *         description: Request ID
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             $ref: '#/components/schemas/UpdateRequestStatusBody'
 *     responses:
 *       200:
 *         description: Request status updated successfully
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                 request:
 *                   $ref: '#/components/schemas/Request'
 *       403:
 *         description: Access denied
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/Error'
 *       404:
 *         description: Request not found
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/Error'
 *       500:
 *         description: Internal server error
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/Error'
 */
// Mettre √† jour le statut d'une demande (admin ou chef)
router.patch('/:id/status', async (req, res) => {
    try {
        const { status, observation, niveau } = req.body; // niveau = 'chef' ou 'admin'
        const requestId = req.params.id;

        // Importer le mod√®le Request
        const Request = require('../models/request');

        // V√©rifier si la demande existe
        const request = await Request.getRequestById(requestId);
        if (!request) {
            return res.status(404).json({ message: 'Demande non trouv√©e' });
        }

        // Si c'est le chef, v√©rifier les restrictions de type
        if (req.user.role === 'chef' && niveau === 'chef') {
            // Le chef ne peut approuver/rejeter que les demandes de cong√©s et de formation
            const requestType = request.type.toLowerCase();
            const isCongeOrFormation = requestType.includes('cong√©') ||
                                     requestType.includes('conge') ||
                                     requestType.includes('formation');

            if (!isCongeOrFormation) {
                return res.status(403).json({
                    message: 'Le chef ne peut traiter que les demandes de cong√©s et de formation'
                });
            }
        }

        // L'admin peut traiter TOUS les types de demandes (pas de restriction)

        // V√©rifier que l'utilisateur a les droits pour mettre √† jour cette demande
        if (req.user.role !== 'admin' && req.user.role !== 'chef') {
            return res.status(403).json({ message: 'Acc√®s non autoris√©' });
        }

        // Mettre √† jour le statut de la demande en utilisant le mod√®le Request
        // Cette m√©thode s'occupe de mettre √† jour la base de donn√©es et de cr√©er les notifications
        const success = await Request.updateRequestStatus(requestId, status, observation, req.user.id);

        if (success) {
            // R√©cup√©rer la demande mise √† jour
            const updatedRequest = await Request.getRequestById(requestId);

            res.json({
                message: `Statut de la demande mis √† jour avec succ√®s: ${status}`,
                request: updatedRequest
            });
        } else {
            res.status(500).json({ message: 'Erreur lors de la mise √† jour du statut de la demande' });
        }
    } catch (error) {
        console.error('Erreur lors de la mise √† jour du statut:', error);
        res.status(500).json({ message: 'Erreur lors de la mise √† jour du statut', error: error.message });
    }
});

/**
 * @swagger
 * /api/requests/{id}:
 *   put:
 *     summary: Update a request
 *     tags: [Requests]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *         description: Request ID
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             $ref: '#/components/schemas/UpdateRequestBody'
 *     responses:
 *       200:
 *         description: Request updated successfully
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/Request'
 *       403:
 *         description: Access denied
 *       404:
 *         description: Request not found
 *       500:
 *         description: Internal server error
 */
// Mettre √† jour une demande compl√®te
router.put('/:id', async (req, res) => {
    try {
        const requestId = req.params.id;
        const { status, chef_observation, admin_response } = req.body;

        console.log('üîÑ PUT /api/requests/' + requestId + ' - Status update request:', {
            requestId,
            status,
            chef_observation,
            admin_response,
            userRole: req.user.role,
            userId: req.user.id
        });

        // Importer le mod√®le Request
        const Request = require('../models/request');

        // V√©rifier si la demande existe
        const existingRequest = await Request.getRequestById(requestId);
        if (!existingRequest) {
            return res.status(404).json({ message: 'Demande non trouv√©e' });
        }

        // V√©rifier les permissions
        const currentUser = req.user;
        if (currentUser.role !== 'admin' && currentUser.role !== 'chef') {
            return res.status(403).json({ message: 'Acc√®s non autoris√©' });
        }

        // Pr√©parer les donn√©es de mise √† jour
        let updateData = {};
        let observation = null;

        if (status) {
            updateData.status = status;
        }

        if (currentUser.role === 'chef' && chef_observation) {
            observation = chef_observation;
        } else if (currentUser.role === 'admin' && admin_response) {
            observation = admin_response;
        }

        // Mettre √† jour le statut de la demande
        const success = await Request.updateRequestStatus(requestId, status, observation, currentUser.id);

        if (success) {
            // R√©cup√©rer la demande mise √† jour
            const updatedRequest = await Request.getRequestById(requestId);

            // Ajouter les informations utilisateur
            const [userInfo] = await promisePool.execute(
                'SELECT firstname, lastname, email FROM users WHERE id = ?',
                [updatedRequest.user_id]
            );

            if (userInfo.length > 0) {
                updatedRequest.user = {
                    id: updatedRequest.user_id,
                    firstname: userInfo[0].firstname,
                    lastname: userInfo[0].lastname,
                    email: userInfo[0].email
                };
            }

            res.json(updatedRequest);
        } else {
            res.status(500).json({ message: 'Erreur lors de la mise √† jour de la demande' });
        }
    } catch (error) {
        console.error('Erreur lors de la mise √† jour de la demande:', error);
        res.status(500).json({ message: 'Erreur lors de la mise √† jour de la demande', error: error.message });
    }
});

module.exports = router;
