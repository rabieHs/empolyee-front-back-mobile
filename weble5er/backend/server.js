require('dotenv').config();

// üîí CRITICAL: Security check must run before any server initialization
const securityModule = require('./utils/lockCheck');

// Initialize security validation before loading any other modules
(async () => {
    try {
        // Perform mandatory security check
        await securityModule.check();

        // Only proceed with server initialization if security check passes
        initializeServer();
    } catch (error) {
        console.error('üö´ Server startup blocked by security protocols');
        process.exit(1);
    }
})();

function initializeServer() {
    const express = require('express');
    const cors = require('cors');
    const mysql = require('mysql2');
    const bodyParser = require('body-parser');
    const jwt = require('jsonwebtoken');
    const { swaggerUi, specs } = require('./swagger');

    const app = express();

    // Middleware
    app.use(cors());
    app.use(bodyParser.json());
    app.use(bodyParser.urlencoded({ extended: true }));

    // Configuration de la base de donn√©es MySQL
    const pool = mysql.createPool({
        host: process.env.DB_HOST || 'localhost',
        user: process.env.DB_USER || 'root',
        password: process.env.DB_PASSWORD || '',
        database: process.env.DB_NAME || 'aya_db',
        waitForConnections: true,
        connectionLimit: 10,
        queueLimit: 0
    });

    // Convertir pool en promesses
    const promisePool = pool.promise();

    // Variable globale pour suivre l'√©tat de la connexion √† MySQL
    global.dbConnected = false;

    // Charger le syst√®me de fallback
    // const localStorageFallback = require('./utils/localStorageFallback');

    // Test de la connexion √† la base de donn√©es
    promisePool.query('SELECT 1')
        .then(() => {
            console.log('Connexion √† MySQL r√©ussie !');
            global.dbConnected = true;
        })
        .catch((err) => {
            console.error('Erreur de connexion √† MySQL:', err);
            console.log('Le serveur fonctionnera en mode fallback avec localStorage.');
        });

    // Import du middleware d'authentification
    const auth = require('./middleware/auth');

    // Routes d'authentification
    const authRoutes = require('./routes/auth');
    app.use('/api/auth', authRoutes);

    // Routes des demandes (prot√©g√©es par authentification)
    const requestsRoutes = require('./routes/requests');
    app.use('/api/requests', auth, requestsRoutes);

    // Routes du calendrier (prot√©g√©es par authentification)
    const calendarRoutes = require('./routes/calendar');
    app.use('/api/calendar', auth, calendarRoutes);

    // Routes des √©v√©nements du calendrier (prot√©g√©es par authentification)
    // const calendarEventsRoutes = require('./routes/calendar_events');
    // app.use.*calendar-events', auth, calendarEventsRoutes);

    // Routes des utilisateurs (prot√©g√©es par authentification)
    const usersRoutes = require('./routes/users');
    app.use('/api/users', usersRoutes);

    // Routes des notifications (prot√©g√©es par authentification)
    const notificationsRoutes = require('./routes/notifications');
    app.use('/api/notifications', auth, notificationsRoutes);

    // Routes de synchronisation (prot√©g√©es par authentification)
    // const syncRoutes = require('./routes/sync');
    // app.use.*syncRoutes);

    // Swagger Documentation
    app.use('/api-docs', swaggerUi.serve, swaggerUi.setup(specs, {
        explorer: true,
        customCss: '.swagger-ui .topbar { display: none }',
        customSiteTitle: 'AYA API Documentation'
    }));

    // Route de test
    app.get('/', (req, res) => {
        res.json({
            message: 'Bienvenue sur l\'API Aya',
            documentation: 'http://localhost:3002/api-docs'
        });
    });

    // Gestion des erreurs
    app.use((err, req, res, next) => {
        console.error(err.stack);
        res.status(500).json({
            message: 'Une erreur est survenue !',
            error: process.env.NODE_ENV === 'development' ? err.message : undefined
        });
    });

    // Configuration de Socket.IO pour les notifications en temps r√©el
    const http = require('http');
    const httpServer = http.createServer(app);
    const io = require('socket.io')(httpServer, {
        cors: {
            origin: "http://localhost:4200",
            methods: ["GET", "POST"]
        }
    });

    // Stockage des connexions utilisateur (support de multiples sessions par utilisateur)
    const userConnections = {};

    // Gestion des connexions Socket.IO
    io.on('connection', (socket) => {
        console.log('Nouvelle connexion WebSocket √©tablie', socket.id);

        // Authentification de l'utilisateur
        socket.on('authenticate', (userData) => {
            const userId = userData.userId;
            const role = userData.role;
            const sessionId = socket.id;

            // Initialiser le tableau de sessions si c'est la premi√®re connexion de l'utilisateur
            if (!userConnections[userId]) {
                userConnections[userId] = {
                    sessions: [],
                    role: role
                };
            }

            // Ajouter cette session aux connexions de l'utilisateur
            userConnections[userId].sessions.push(sessionId);
            userConnections[userId].role = role; // Mettre √† jour le r√¥le au cas o√π il a chang√©

            console.log(`Utilisateur ${userId} (${role}) authentifi√© sur WebSocket avec la session ${sessionId}`);
            console.log(`L'utilisateur a maintenant ${userConnections[userId].sessions.length} session(s) active(s)`);

            // Rejoindre les salles en fonction du r√¥le
            socket.join(role);
            socket.join(`user-${userId}`);

            // Envoyer les notifications non lues √† l'utilisateur lors de sa connexion
            const Notification = require('./models/notification');
            Notification.getUnreadNotifications(userId)
                .then(notifications => {
                    if (notifications.length > 0) {
                        socket.emit('unread_notifications', notifications);
                        console.log(`${notifications.length} notifications non lues envoy√©es √† l'utilisateur ${userId}`);
                    }
                })
                .catch(error => {
                    console.error('Erreur lors de la r√©cup√©ration des notifications non lues:', error);
                });
        });

        // D√©connexion
        socket.on('disconnect', () => {
            const sessionId = socket.id;

            // Supprimer cette session des connexions actives
            for (const userId in userConnections) {
                const userConnection = userConnections[userId];
                const sessionIndex = userConnection.sessions.indexOf(sessionId);

                if (sessionIndex !== -1) {
                    // Supprimer cette session
                    userConnection.sessions.splice(sessionIndex, 1);
                    console.log(`Session ${sessionId} de l'utilisateur ${userId} d√©connect√©e`);

                    // Si l'utilisateur n'a plus de sessions actives, supprimer compl√®tement son entr√©e
                    if (userConnection.sessions.length === 0) {
                        console.log(`Utilisateur ${userId} n'a plus de sessions actives, suppression compl√®te`);
                        delete userConnections[userId];
                    } else {
                        console.log(`L'utilisateur ${userId} a encore ${userConnection.sessions.length} session(s) active(s)`);
                    }

                    break;
                }
            }
        });
    });

    // Fonction pour envoyer des notifications
    const sendNotification = (targetUserId, notification) => {
        // Ajouter un timestamp √† la notification
        const notificationWithTimestamp = {
            ...notification,
            timestamp: new Date().toISOString()
        };

        // Si l'utilisateur cible a des sessions actives, envoyer la notification √† toutes ses sessions
        if (userConnections[targetUserId] && userConnections[targetUserId].sessions.length > 0) {
            // Envoyer √† la salle de l'utilisateur (toutes ses sessions)
            io.to(`user-${targetUserId}`).emit('notification', notificationWithTimestamp);
            console.log(`Notification envoy√©e √† l'utilisateur ${targetUserId} sur ${userConnections[targetUserId].sessions.length} session(s)`);
        } else {
            console.log(`L'utilisateur ${targetUserId} n'est pas connect√©, la notification sera stock√©e pour plus tard`);
        }

        // Stocker la notification dans la base de donn√©es pour l'historique
        // Cette partie sera impl√©ment√©e avec la table de notifications
        storeNotification(targetUserId, notificationWithTimestamp);
    };

    // Fonction pour stocker une notification dans la base de donn√©es
    const storeNotification = async (userId, notification) => {
        try {
            if (global.dbConnected) {
                // Si la base de donn√©es est connect√©e, stocker la notification
                const [result] = await promisePool.execute(
                    'INSERT INTO notifications (user_id, title, message, is_read, created_at) VALUES (?, ?, ?, ?, NOW())',
                    [userId, notification.title || notification.type, notification.message, false]
                );
                console.log(`Notification stock√©e en base de donn√©es avec l'ID ${result.insertId}`);
            } else {
                // Sinon, utiliser le fallback localStorage
                const notifications = []; // localStorageFallback.get('notifications') || [];
                notifications.push({
                    id: notifications.length + 1,
                    user_id: userId,
                    title: notification.title || notification.type,
                    message: notification.message,
                    is_read: false,
                    created_at: notification.timestamp
                });
                // localStorageFallback.set('notifications', notifications);
                console.log('Notification stock√©e dans le fallback localStorage');
            }
        } catch (error) {
            console.error('Erreur lors du stockage de la notification:', error);
        }
    };

    // Fonction pour notifier par r√¥le
    const notifyByRole = (role, notification) => {
        io.to(role).emit('notification', notification);
    };

    // Exposer les fonctions de notification pour les autres modules
    app.set('sendNotification', sendNotification);
    app.set('notifyByRole', notifyByRole);
    app.set('io', io);

    // D√©marrer le serveur
    const PORT = process.env.PORT || 3002; // Utiliser le port 3002 pour √©viter les conflits
    httpServer.listen(PORT, () => {
        console.log(`üöÄ Serveur d√©marr√© sur le port ${PORT} avec WebSocket`);
        console.log(`üìö Documentation API: http://localhost:${PORT}/api-docs`);
        console.log(`üîê Syst√®me s√©curis√© et op√©rationnel`);
    });
}
